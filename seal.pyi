from __future__ import annotations

from enum import IntEnum
from typing import Iterable, Sequence, TypeAlias, overload

import numpy as np
from numpy.typing import NDArray

__version__: str

ParmsId: TypeAlias = Sequence[int]
FloatLikeArray: TypeAlias = Iterable[float]
ComplexLikeArray: TypeAlias = Iterable[complex]
IntLikeArray: TypeAlias = Iterable[int]


class scheme_type(IntEnum):
    none: int
    bfv: int
    ckks: int
    bgv: int


class compr_mode_type(IntEnum):
    none: int
    zlib: int
    zstd: int


class sec_level_type(IntEnum):
    none: int
    tc128: int
    tc192: int
    tc256: int


class error_type(IntEnum):
    none: int
    success: int
    invalid_scheme: int
    invalid_coeff_modulus_size: int
    invalid_coeff_modulus_bit_count: int
    invalid_coeff_modulus_no_ntt: int
    invalid_poly_modulus_degree: int
    invalid_poly_modulus_degree_non_power_of_two: int
    invalid_parameters_too_large: int
    invalid_parameters_insecure: int
    failed_creating_rns_base: int
    invalid_plain_modulus_bit_count: int
    invalid_plain_modulus_coprimality: int
    invalid_plain_modulus_too_large: int
    invalid_plain_modulus_nonzero: int
    failed_creating_rns_tool: int


class VectorDouble(list[float]): ...
class VectorComplex(list[complex]): ...
class VectorUInt(list[int]): ...
class VectorInt(list[int]): ...


class MemoryPoolHandle:
    def __init__(self) -> None: ...
    @staticmethod
    def Global() -> MemoryPoolHandle: ...
    @staticmethod
    def ThreadLocal() -> MemoryPoolHandle: ...
    @staticmethod
    def New(clear_on_destruction: bool = False) -> MemoryPoolHandle: ...
    def pool_count(self) -> int: ...
    def alloc_byte_count(self) -> int: ...
    def use_count(self) -> int: ...
    def is_initialized(self) -> bool: ...


class MemoryManager:
    @staticmethod
    def GetPool() -> MemoryPoolHandle: ...


class Modulus:
    def __init__(self, value: int) -> None: ...
    def bit_count(self) -> int: ...
    def value(self) -> int: ...
    def is_zero(self) -> bool: ...
    def is_prime(self) -> bool: ...
    def reduce(self, value: int) -> int: ...


class EncryptionParameters:
    @overload
    def __init__(self, scheme: scheme_type) -> None: ...
    @overload
    def __init__(self, other: EncryptionParameters) -> None: ...
    def set_poly_modulus_degree(self, poly_modulus_degree: int) -> None: ...
    def set_coeff_modulus(self, coeff_modulus: Sequence[Modulus]) -> None: ...
    @overload
    def set_plain_modulus(self, plain_modulus: Modulus) -> None: ...
    @overload
    def set_plain_modulus(self, plain_modulus: int) -> None: ...
    def scheme(self) -> scheme_type: ...
    def poly_modulus_degree(self) -> int: ...
    def coeff_modulus(self) -> Sequence[Modulus]: ...
    def plain_modulus(self) -> Modulus: ...
    @overload
    def save(self, path: str) -> None: ...
    @overload
    def save(self, path: str, compr_mode: compr_mode_type) -> None: ...
    def load(self, path: str) -> None: ...
    def load_bytes(self, data: bytes) -> None: ...
    def save_size(self, compr_mode: compr_mode_type = ...) -> int: ...
    def to_bytes(self, compr_mode: compr_mode_type = ...) -> bytes: ...


class EncryptionParameterQualifiers:
    parameter_error: error_type
    using_fft: bool
    using_ntt: bool
    using_batching: bool
    using_fast_plain_lift: bool
    using_descending_modulus_chain: bool
    sec_level: sec_level_type
    def parameters_set(self) -> bool: ...
    def parameter_error_name(self) -> str: ...
    def parameter_error_message(self) -> str: ...


class ContextData:
    def parms(self) -> EncryptionParameters: ...
    def parms_id(self) -> ParmsId: ...
    def qualifiers(self) -> EncryptionParameterQualifiers: ...
    def total_coeff_modulus(self) -> int: ...
    def total_coeff_modulus_bit_count(self) -> int: ...
    def next_context_data(self) -> ContextData | None: ...
    def chain_index(self) -> int: ...


class SEALContext:
    def __init__(
        self,
        parms: EncryptionParameters,
        expand_mod_chain: bool = True,
        sec_level: sec_level_type = sec_level_type.tc128,
    ) -> None: ...
    def get_context_data(self, parms_id: ParmsId) -> ContextData | None: ...
    def key_context_data(self) -> ContextData: ...
    def first_context_data(self) -> ContextData: ...
    def last_context_data(self) -> ContextData: ...
    def parameters_set(self) -> bool: ...
    def parameter_error_name(self) -> str: ...
    def parameter_error_message(self) -> str: ...
    def first_parms_id(self) -> ParmsId: ...
    def last_parms_id(self) -> ParmsId: ...
    def using_keyswitching(self) -> bool: ...
    def from_cipher_str(self, data: bytes | str) -> Ciphertext: ...
    def from_plain_str(self, data: bytes | str) -> Plaintext: ...
    def from_secret_str(self, data: bytes | str) -> SecretKey: ...
    def from_public_str(self, data: bytes | str) -> PublicKey: ...
    def from_relin_str(self, data: bytes | str) -> RelinKeys: ...
    def from_galois_str(self, data: bytes | str) -> GaloisKeys: ...


class CoeffModulus:
    @staticmethod
    def MaxBitCount(poly_modulus_degree: int, sec_level: sec_level_type = sec_level_type.tc128) -> int: ...
    @staticmethod
    def BFVDefault(poly_modulus_degree: int, sec_level: sec_level_type = sec_level_type.tc128) -> Sequence[Modulus]: ...
    @overload
    @staticmethod
    def Create(poly_modulus_degree: int, bit_sizes: Sequence[int]) -> Sequence[Modulus]: ...
    @overload
    @staticmethod
    def Create(poly_modulus_degree: int, plain_modulus: Modulus, bit_sizes: Sequence[int]) -> Sequence[Modulus]: ...


class PlainModulus:
    @overload
    @staticmethod
    def Batching(poly_modulus_degree: int, bit_size: int) -> Modulus: ...
    @overload
    @staticmethod
    def Batching(poly_modulus_degree: int, bit_sizes: Sequence[int]) -> Sequence[Modulus]: ...


class Plaintext:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, coeff_count: int) -> None: ...
    @overload
    def __init__(self, coeff_count: int, capacity: int) -> None: ...
    @overload
    def __init__(self, hex_poly: str) -> None: ...
    @overload
    def __init__(self, other: Plaintext) -> None: ...
    @overload
    def set_zero(self) -> None: ...
    @overload
    def set_zero(self, start_coeff: int) -> None: ...
    @overload
    def set_zero(self, start_coeff: int, length: int) -> None: ...
    def is_zero(self) -> bool: ...
    def capacity(self) -> int: ...
    def coeff_count(self) -> int: ...
    def significant_coeff_count(self) -> int: ...
    def nonzero_coeff_count(self) -> int: ...
    def to_string(self) -> str: ...
    def is_ntt_form(self) -> bool: ...
    def parms_id(self) -> ParmsId: ...
    @overload
    def scale(self) -> float: ...
    @overload
    def scale(self, value: float) -> None: ...
    @overload
    def save(self, path: str) -> None: ...
    @overload
    def save(self, path: str, compr_mode: compr_mode_type) -> None: ...
    def load(self, context: SEALContext, path: str) -> None: ...
    def load_bytes(self, context: SEALContext, data: bytes) -> None: ...
    def save_size(self, compr_mode: compr_mode_type = ...) -> int: ...
    def to_bytes(self, compr_mode: compr_mode_type = ...) -> bytes: ...


class Ciphertext:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, context: SEALContext) -> None: ...
    @overload
    def __init__(self, context: SEALContext, parms_id: ParmsId) -> None: ...
    @overload
    def __init__(self, context: SEALContext, parms_id: ParmsId, size_capacity: int) -> None: ...
    @overload
    def __init__(self, other: Ciphertext) -> None: ...
    def coeff_modulus_size(self) -> int: ...
    def poly_modulus_degree(self) -> int: ...
    def size(self) -> int: ...
    def size_capacity(self) -> int: ...
    def is_transparent(self) -> bool: ...
    def is_ntt_form(self) -> bool: ...
    def parms_id(self) -> ParmsId: ...
    @overload
    def scale(self) -> float: ...
    @overload
    def scale(self, value: float) -> None: ...
    @overload
    def save(self, path: str) -> None: ...
    @overload
    def save(self, path: str, compr_mode: compr_mode_type) -> None: ...
    def load(self, context: SEALContext, path: str) -> None: ...
    def load_bytes(self, context: SEALContext, data: bytes) -> None: ...
    def save_size(self, compr_mode: compr_mode_type = ...) -> int: ...
    def to_string(self, compr_mode: compr_mode_type = ...) -> bytes: ...


class SecretKey:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: SecretKey) -> None: ...
    def parms_id(self) -> ParmsId: ...
    def save(self, path: str) -> None: ...
    def load(self, context: SEALContext, path: str) -> None: ...
    def to_string(self) -> bytes: ...


class PublicKey:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: PublicKey) -> None: ...
    def parms_id(self) -> ParmsId: ...
    def save(self, path: str) -> None: ...
    def load(self, context: SEALContext, path: str) -> None: ...
    def to_string(self) -> bytes: ...


class KSwitchKeys:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: KSwitchKeys) -> None: ...
    def size(self) -> int: ...
    def parms_id(self) -> ParmsId: ...
    def save(self, path: str) -> None: ...
    def load(self, context: SEALContext, path: str) -> None: ...


class RelinKeys(KSwitchKeys):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: KSwitchKeys) -> None: ...
    @staticmethod
    def get_index(key_power: int) -> int: ...
    def has_key(self, key_power: int) -> bool: ...
    def to_string(self) -> bytes: ...


class GaloisKeys(KSwitchKeys):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: KSwitchKeys) -> None: ...
    @staticmethod
    def get_index(galois_elt: int) -> int: ...
    def has_key(self, galois_elt: int) -> bool: ...
    def to_string(self) -> bytes: ...


class KeyGenerator:
    @overload
    def __init__(self, context: SEALContext) -> None: ...
    @overload
    def __init__(self, context: SEALContext, secret_key: SecretKey) -> None: ...
    def secret_key(self) -> SecretKey: ...
    @overload
    def create_public_key(self) -> PublicKey: ...
    @overload
    def create_public_key(self, destination: PublicKey) -> None: ...
    @overload
    def create_relin_keys(self) -> RelinKeys: ...
    @overload
    def create_relin_keys(self, destination: RelinKeys) -> None: ...
    @overload
    def create_galois_keys(self) -> GaloisKeys: ...
    @overload
    def create_galois_keys(self, destination: GaloisKeys) -> None: ...
    @overload
    def create_galois_keys(self, galois_elts: Sequence[int], destination: GaloisKeys) -> None: ...


class Encryptor:
    @overload
    def __init__(self, context: SEALContext, public_key: PublicKey) -> None: ...
    @overload
    def __init__(self, context: SEALContext, secret_key: SecretKey) -> None: ...
    @overload
    def __init__(self, context: SEALContext, public_key: PublicKey, secret_key: SecretKey) -> None: ...
    def set_public_key(self, public_key: PublicKey) -> None: ...
    def set_secret_key(self, secret_key: SecretKey) -> None: ...
    @overload
    def encrypt_zero(self) -> Ciphertext: ...
    @overload
    def encrypt_zero(self, destination: Ciphertext) -> None: ...
    @overload
    def encrypt_zero(self, parms_id: ParmsId) -> Ciphertext: ...
    @overload
    def encrypt_zero(self, parms_id: ParmsId, destination: Ciphertext) -> None: ...
    @overload
    def encrypt(self, plain: Plaintext) -> Ciphertext: ...
    @overload
    def encrypt(self, plain: Plaintext, destination: Ciphertext) -> None: ...
    @overload
    def encrypt_symmetric(self, plain: Plaintext) -> Ciphertext: ...
    @overload
    def encrypt_symmetric(self, plain: Plaintext, destination: Ciphertext) -> None: ...


class Evaluator:
    def __init__(self, context: SEALContext) -> None: ...
    def negate_inplace(self, encrypted: Ciphertext) -> None: ...
    def negate(self, encrypted1: Ciphertext) -> Ciphertext: ...
    def add_inplace(self, encrypted1: Ciphertext, encrypted2: Ciphertext) -> None: ...
    def add(self, encrypted1: Ciphertext, encrypted2: Ciphertext) -> Ciphertext: ...
    def add_many(self, encrypteds: Sequence[Ciphertext]) -> Ciphertext: ...
    def sub_inplace(self, encrypted1: Ciphertext, encrypted2: Ciphertext) -> None: ...
    def sub(self, encrypted1: Ciphertext, encrypted2: Ciphertext) -> Ciphertext: ...
    def multiply_inplace(self, encrypted1: Ciphertext, encrypted2: Ciphertext) -> None: ...
    def multiply(self, encrypted1: Ciphertext, encrypted2: Ciphertext) -> Ciphertext: ...
    def square_inplace(self, encrypted1: Ciphertext) -> None: ...
    def square(self, encrypted1: Ciphertext) -> Ciphertext: ...
    def relinearize_inplace(self, encrypted1: Ciphertext, relin_keys: RelinKeys) -> None: ...
    def relinearize(self, encrypted1: Ciphertext, relin_keys: RelinKeys) -> Ciphertext: ...
    @overload
    def mod_switch_to_next(self, encrypted: Ciphertext) -> Ciphertext: ...
    @overload
    def mod_switch_to_next(self, plain: Plaintext) -> Plaintext: ...
    @overload
    def mod_switch_to_next_inplace(self, encrypted: Ciphertext) -> None: ...
    @overload
    def mod_switch_to_next_inplace(self, plain: Plaintext) -> None: ...
    @overload
    def mod_switch_to_inplace(self, encrypted: Ciphertext, parms_id: ParmsId) -> None: ...
    @overload
    def mod_switch_to_inplace(self, plain: Plaintext, parms_id: ParmsId) -> None: ...
    @overload
    def mod_switch_to(self, encrypted: Ciphertext, parms_id: ParmsId) -> Ciphertext: ...
    @overload
    def mod_switch_to(self, plain: Plaintext, parms_id: ParmsId) -> Plaintext: ...
    def rescale_to_next(self, encrypted: Ciphertext) -> Ciphertext: ...
    def rescale_to_next_inplace(self, encrypted: Ciphertext) -> None: ...
    def rescale_to_inplace(self, encrypted: Ciphertext, parms_id: ParmsId) -> None: ...
    def rescale_to(self, encrypted: Ciphertext, parms_id: ParmsId) -> Ciphertext: ...
    def multiply_many(self, encrypteds: Sequence[Ciphertext], relin_keys: RelinKeys) -> Ciphertext: ...
    def exponentiate_inplace(self, encrypted: Ciphertext, exponent: int, relin_keys: RelinKeys) -> None: ...
    def exponentiate(self, encrypted: Ciphertext, exponent: int, relin_keys: RelinKeys) -> Ciphertext: ...
    def add_plain_inplace(self, encrypted: Ciphertext, plain: Plaintext) -> None: ...
    def add_plain(self, encrypted: Ciphertext, plain: Plaintext) -> Ciphertext: ...
    def sub_plain_inplace(self, encrypted: Ciphertext, plain: Plaintext) -> None: ...
    def sub_plain(self, encrypted: Ciphertext, plain: Plaintext) -> Ciphertext: ...
    def multiply_plain_inplace(self, encrypted: Ciphertext, plain: Plaintext) -> None: ...
    def multiply_plain(self, encrypted: Ciphertext, plain: Plaintext) -> Ciphertext: ...
    @overload
    def transform_to_ntt_inplace(self, plain: Plaintext, parms_id: ParmsId) -> None: ...
    @overload
    def transform_to_ntt_inplace(self, encrypted: Ciphertext) -> None: ...
    @overload
    def transform_to_ntt(self, plain: Plaintext, parms_id: ParmsId) -> Plaintext: ...
    @overload
    def transform_to_ntt(self, encrypted: Ciphertext) -> Ciphertext: ...
    def transform_from_ntt_inplace(self, encrypted: Ciphertext) -> None: ...
    def transform_from_ntt(self, encrypted_ntt: Ciphertext) -> Ciphertext: ...
    def apply_galois_inplace(self, encrypted: Ciphertext, galois_elt: int, galois_keys: GaloisKeys) -> None: ...
    def apply_galois(self, encrypted: Ciphertext, galois_elt: int, galois_keys: GaloisKeys) -> Ciphertext: ...
    def rotate_rows_inplace(self, encrypted: Ciphertext, steps: int, galois_keys: GaloisKeys) -> None: ...
    def rotate_rows(self, encrypted: Ciphertext, steps: int, galois_keys: GaloisKeys) -> Ciphertext: ...
    def rotate_columns_inplace(self, encrypted: Ciphertext, galois_keys: GaloisKeys) -> None: ...
    def rotate_columns(self, encrypted: Ciphertext, galois_keys: GaloisKeys) -> Ciphertext: ...
    def rotate_vector_inplace(self, encrypted: Ciphertext, steps: int, galois_keys: GaloisKeys) -> None: ...
    def rotate_vector(self, encrypted: Ciphertext, steps: int, galois_keys: GaloisKeys) -> Ciphertext: ...
    def complex_conjugate_inplace(self, encrypted: Ciphertext, galois_keys: GaloisKeys) -> None: ...
    def complex_conjugate(self, encrypted: Ciphertext, galois_keys: GaloisKeys) -> Ciphertext: ...


class CKKSEncoder:
    def __init__(self, context: SEALContext) -> None: ...
    def slot_count(self) -> int: ...
    @overload
    def encode(self, values: FloatLikeArray, scale: float) -> Plaintext: ...
    @overload
    def encode(self, values: FloatLikeArray, scale: float, destination: Plaintext) -> None: ...
    @overload
    def encode(self, value: float, scale: float) -> Plaintext: ...
    @overload
    def encode(self, value: float, scale: float, destination: Plaintext) -> None: ...
    @overload
    def encode(self, value: int) -> Plaintext: ...
    @overload
    def encode(self, value: int, destination: Plaintext) -> None: ...
    @overload
    def encode_complex(self, values: ComplexLikeArray, scale: float) -> Plaintext: ...
    @overload
    def encode_complex(self, values: ComplexLikeArray, scale: float, destination: Plaintext) -> None: ...
    @overload
    def encode_complex(self, value: complex, scale: float) -> Plaintext: ...
    @overload
    def encode_complex(self, value: complex, scale: float, destination: Plaintext) -> None: ...
    def decode(self, plain: Plaintext) -> NDArray[np.float64]: ...
    def decode_complex(self, plain: Plaintext) -> NDArray[np.complex128]: ...


class Decryptor:
    def __init__(self, context: SEALContext, secret_key: SecretKey) -> None: ...
    @overload
    def decrypt(self, encrypted: Ciphertext, destination: Plaintext) -> None: ...
    @overload
    def decrypt(self, encrypted: Ciphertext) -> Plaintext: ...
    def invariant_noise_budget(self, encrypted: Ciphertext) -> int: ...


class BatchEncoder:
    def __init__(self, context: SEALContext) -> None: ...
    def slot_count(self) -> int: ...
    @overload
    def encode(self, values: Sequence[int], destination: Plaintext) -> None: ...
    @overload
    def encode(self, values: IntLikeArray) -> Plaintext: ...
    def decode(self, plain: Plaintext) -> NDArray[np.int64]: ...
    def decode_uint64(self, plain: Plaintext) -> NDArray[np.uint64]: ...
